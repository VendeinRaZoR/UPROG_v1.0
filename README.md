**Универсальный программатор UPROG версии 1.0**

**Описание**

Предназначен для прошивки микросхем памяти через различные наиболее простые и распространенные интерфейсы, такие как LPT и COM(USB-UART).

Имеется возможность добавлять свои типы микросхем пользователем, посредством создания собственных библиотек для работы с конкретными семействами микросхем памяти определенного производителя. В меню программатора новые микросхемы добавляются посредством создания их описания в виде JSON файлов в папке json.

Имеется возможность добавлять свои форматы файлов прошивок, посредством модификации модулей в Python скриптах в папке python.

Библиотеки интерфейсов и протоколов не должны изменяться пользователем, а поставляются и обновляются как есть. В исключительных случаях возможно добавление новой библиотеки протокола пользователем

**Особенности программатора**  **UPROG**  **версии 1.0:**

- **Возможность создания пользовательских библиотек** - для работы с микросхемами памяти, но, исключительно, с перекомпиляцией всего проекта;
- **Работа только с**  **LPT**  **портом** – другие интерфейсы пока не поддерживаются;
- **Добавление новых микросхем в меню посредством**  **JSON**  **файлов –** добавление пользовательских микросхем, производителей памяти и ссылок на информацию о них в меню программатора посредством добавления и редактирования JSON файлов;
- **Добавление новых форматов файлов прошивок –** добавление пользовательских форматов прошивок (открытие и сохранение) путем дополнения логики модулей _fwSave_ и _fwLoad_ с указанием нового формата в переменной _fwFormat_ в Python скриптах;
- **Наглядный процесс прошивки микросхемы –** пословная визуализация (побайтная) процесса прошивки той или иной микросхемы в HEX таблице её адресного пространства;
- **Схема программатора для каждой микросхемы –** принципиальная схема программатора для каждой микросхемы памяти отображается на отдельной вкладке при выборе соответствующего типа микросхемы;
- **Кроссплатформенность –** поддержка наиболее распространенных ОС, таких как Windows и Linux (Версия для MacOS пока не рассматривается, так как LPT порт присутствует только на оооочень старых Mac&#39;ах).

Версия для Linux пока не совсем доработанная и графический интерфейс неправильно форматирован, как на рисунках ниже, из-за отличий в шрифтах и прочем;

![](/README.image/1.bmp)

Версия для Linux

![Shape2](RackMultipart20220127-4-1v82u2a_html_9ff8d043e787f99f.gif)

Версия для Windows

**Список изначально поддерживаемых микросхем программатором**  **UPROG**  **версии 1.0:**

**Фирма**  **ATMEL:**

- AT17LV(C)65A
- AT17LV(C)128A
- AT17LV(C)256A
- AT17LV(C)512A
- AT17LV(C)010A
- AT17LV(C)002A
- AT17LV(C)040A

В следующих версиях список изначально поддерживаемых микросхем памяти будет пополняться. Также необходимо сделать загрузку уже откомпилированных пользовательских динамических библиотек DLL посредством метода _LoadLibrary_ без перекомпиляции всего проекта.

**Минимальные системные требования для программатора**  **UPROG**  **версии 1.0:**

- Операционная система: Windows (начиная с XP), Linux с графической оболочкой MATE, Cinnamon и прочие;
- Процессор: x86 233 МГц Pentium II
- Память ОЗУ: 128 Мбайт
- Память ПЗУ: 50 Мбайт свободного места на диске

В следующих версиях, возможно, появится совместимость с ещё более старыми версиями ОС, такими как Windows 95 и Windows 98, а, соответственно, совместимость с более старыми процессорами архитектуры x86, начиная с процессора 80386.

Если будет возможно, то, когда-нибудь, UPROG можно будет запустить под MS-DOS. Думаю, что модульность программы позволит это сделать с некоторыми ограничениями.

Также, желательна, в дальнейшем, поддержка архитектуры ARM.

**Инструкция**

Рассмотрим, в качестве обучающего примера, процесс прошивки микросхемы AT17LV010 под ОС Windows.

Запустим UPROG\_Release.bat из папки _Deploy __/__ Windows __/__ msvc __\_2010\___ qt__\_5\_0\_2/_

Запустится окно программы:

![Shape3](RackMultipart20220127-4-1v82u2a_html_9ff8d043e787f99f.gif)

Далее можно активировать дополнительное меню с помощью клавиши _Ctrl_:

![Shape4](RackMultipart20220127-4-1v82u2a_html_aed10f777e79c31.gif)

При нажатии на ссылку в разделе &quot;Производитель&quot; (подчеркнутый пункт выпадаюшего списка меню) откроется браузер с сайтом производителя (либо откроется файл с его описанием, хранящийся на жестком диске, если таковой будет задан в JSON файле).

При нажатии на ссылку в разделе &quot;Микросхема&quot; можно перейти на сайт с документацией на микросхему либо откроется документация на жестком диске, если таковая указана в JSON файле.

При нажатии на ссылку в разделе &quot;Программатор&quot; будет осуществлен переход на вкладку с принципиальной схемой программатора:

![Shape5](RackMultipart20220127-4-1v82u2a_html_32cfc7a411ac6dd3.gif)

Либо, если файл со схемой не задан в JSON файле, то откроется подобная вкладка:

![Shape6](RackMultipart20220127-4-1v82u2a_html_9df3eb53b9e178ee.gif)

Чтобы открыть схему во вкладке в полном размере, необходимо нажать на _Ctrl_(дополнительное меню) и нажать на схему. В этом случае откроется картинка средствами системного просмоторщика картинок.

Вернемся обратно к первой вкладке. Выберем производителя _Atmel_из списка:

![Shape7](RackMultipart20220127-4-1v82u2a_html_f01ebd982ce90d31.gif)

Данный список формируется посредством чтения JSON файлов из папки _json_.

Далее выберем микросхему AT17LV010 из списка:

![Shape8](RackMultipart20220127-4-1v82u2a_html_306fd903e2444551.gif)

Данный список также формируется посредством чтения JSON файлов для данного производителя из папки _json_.

Далее выберем программатор из списка:

![Shape9](RackMultipart20220127-4-1v82u2a_html_3e38d30e3ea53b9.gif)

Данный список также формируется посредством чтения JSON файлов для данных производителя и микросхемы из папки _json_. В данном случае программатор LPT\_I2C означает протокол I2C поверх интерфейса LPT (параллельный порт).

Выбрав необходимые нам микросхему и программатор, настроим программатор:

![Shape10](RackMultipart20220127-4-1v82u2a_html_e5d0b71b31cb10f1.gif)

Для этого заменим адрес 0378 на свой (в данном случае D050). Адрес LPT порта в Windows можно посмотреть в Диспетчере устройств в свойствах контроллера LPT:

Далее, необходимо нажать Enter, чтобы параметры установились, ранее поле, ставшее красным, должно стать белым:

![Shape11](RackMultipart20220127-4-1v82u2a_html_cc0be43291db70ef.gif)

Настроив программатор, настроим параметры конфигурационной памяти для программируемой микросхемы. К примеру, установим параметр RESET в 1. Для этого необходимо нажать на значок фигурных скобок соответствующего поля, чтобы там появился крестик.

Для данной микросхемы, сигнал RESET установленный в 1 значит, что наша микросхема будет сбрасываться по сигналу RESET высокого уровня, а активный уровень сигнала OE будет низким.

После того как все параметры настроены, можно приступать к записи прошивки. Для этого необходимо нажать на кнопку запись:

![Shape12](RackMultipart20220127-4-1v82u2a_html_36f7ea0b103a898b.gif)

После чего откроется окно предупреждения, что параметры LPT порта заданы верно:

![](RackMultipart20220127-4-1v82u2a_html_afab816b6529fec1.png)

После нажатия на Да (Yes), откроется окно выбора файла прошивки, где необходимо будет найти и открыть файл существующего формата:

![Shape13](RackMultipart20220127-4-1v82u2a_html_b039dab83ca04ebb.gif)

Если нажать на Отмену (Cancel), то появится диалоговое окно с предложением стереть память микросхемы:

![Shape14](RackMultipart20220127-4-1v82u2a_html_dc422c66badc8fa6.gif)

Если файл открыть, то появится сообщение о том, что питание подано и сигналы установлены в начальное состояние:

![](RackMultipart20220127-4-1v82u2a_html_52ba9fefc5b72407.png)

После утвердительного ответа, программатор попытается считать информацию с микросхемы, такую как, например, код производителя и выведет результат, если код производителя отличается:

![Shape15](RackMultipart20220127-4-1v82u2a_html_d4f38e8cd05bdebe.gif)

В нашем случае, все байты равны 0xFF. Это должно насторожить, поскольку хотя бы какие-нибудь из первых 2-х байтов должны быть не 0xFF. Это может означать, что микросхема не определяется. Однако, так может быть даже когда микросхема определилась, но код производителя по каким-то причинам, был стёрт.

Чтобы проверить, что микросхема определяется, отвечаем утвердительно и смотрим результат. Если микросхема не определяется, то появится следующее окно:

![Shape16](RackMultipart20220127-4-1v82u2a_html_aa5ad45a27e9c5cc.gif)

Если микросхема нормально определилась и отвечает на запросы, то откроется вкладка с HEX таблицей памяти микросхемы и процессом прошивки в реальном времени:

![Shape17](RackMultipart20220127-4-1v82u2a_html_3f012672d5cffe0.gif)

**Зеленая** индикация проводника показывает, что данные байты были уже записаны в память. **Красная** индикация проводника показывает, что этот байт в процессе записи в память. **Оранжевая** индикация проводника означает, что данные байты ожидают записи.

Процесс записи также отображается в правом нижнем углу в процентах.

В любой момент можно прервать как запись так и чтение нажатием на клавишу ESC:

![Shape18](RackMultipart20220127-4-1v82u2a_html_c360faef55cb40c.gif)

Данное окошко также отображается по завершении процесса записи (стирания) или чтения.

Чтобы убедиться, что данные записались верно, необходимо произвести чтение из памяти микросхемы:

![Shape19](RackMultipart20220127-4-1v82u2a_html_a12d3282275d72ed.gif)

Далее, всё аналогично процессу записи. Выбираем файл прошивки для сохранения:

![Shape20](RackMultipart20220127-4-1v82u2a_html_365a875ce4032d22.gif)

Если нажать Отмена (Cancel), то вылезет следующее окно:

![Shape21](RackMultipart20220127-4-1v82u2a_html_f073cd1af82a2885.gif)

После утвердительного ответа, прошивка будет считана без сохранения её в файл. Индикация процесса чтения аналогична, только считанные байты появляются в HEX таблице **зеленым цветом** вместо 0xFF по мере чтения.

![](RackMultipart20220127-4-1v82u2a_html_f4bdcccea69a98dd.png)

В версии для Linux все операции аналогичны. Единственный нюанс – **запускать программу надо с использованием**  **SUDO**  **!!!** Иначе не будет работать LPT порт.

Другой особенностью версии для Linux является её недоработанность. Графический интерфейс и функционал может отличаться от версии под Windows:

![Shape22](RackMultipart20220127-4-1v82u2a_html_43e7ff38cc83050a.gif)

В следующих версиях многое будет исправлено, надеюсь…

Адрес LPT порта в Linux можно получить с помощью команды _lspci_, если LPT порт присутствует в виде карты расширения на шине PCI или PCI-Express, либо с помощью команды _lshw_, если LPT порт уже стоит на плате.